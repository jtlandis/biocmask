% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select.R
\name{select.SummarizedExperiment}
\alias{select.SummarizedExperiment}
\title{select assays, rowData, and colData names}
\usage{
\method{select}{SummarizedExperiment}(.data, ...)
}
\arguments{
\item{.data}{a \code{SummarizedExperiment} object}

\item{...}{<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> one or more selection
expressions. Supports wrapping expressions within the
<\code{\link[=biocmask-context]{biocmask-contexts}}>.}
}
\description{
Select one or more values from each context. By default omitting an expression
for a context is the same as selecting NOTHING from that context.

The <\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> implementation within
\code{biocmask} is almost similar to \code{dplyr} except when used within the
\code{across()} function. When used from \code{accross()}, the data provided to
\link[tidyselect:eval_select]{eval_select} is a zero length slice of the data.
This was an intentional choice to prevent the evaluation of potentionally
expensive chopping operations for S4Vectors. This means that predicate
function from \code{\link[tidyselect:where]{where()}} will NOT be able to query the
original data.
}
\examples{


# only keep assays, other contexts are dropped
select(se_simple, everything())

# only keep rowData, other contexts are dropped
select(se_simple, rows(everything()))

select(se_simple, rows(where(is.numeric)))

# Note on `where()` clause, all data is available within select
select(se_simple, rows(where(~any(grepl("-", .x)))))

# within an `across()`, only a zero-length slice avialble, so the
# `where()` predicate cannot access the data
mutate(se_simple,
       rows(
        across(where(~any(grepl("-", .x))),
               ~sprintf("\%s foo", .x))))
# here is an acceptable usage of the `where()` predicate
mutate(se_simple,
       rows(
        across(where(is.character),
               ~sprintf("\%s foo", .x))))

}
